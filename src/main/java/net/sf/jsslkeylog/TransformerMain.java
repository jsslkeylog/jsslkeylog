package net.sf.jsslkeylog;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.classfile.ClassFile;
import java.lang.classfile.ClassTransform;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.StandardOpenOption;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.regex.Pattern;

/**
 * Main transformer class that implements the required transformations to get
 * the SSL secrets.
 */
public class TransformerMain implements ClassFileTransformer {

	/**
	 * Classes to transform that contain RSA secrets (by Java version).
	 */
	private static String[] RSA_CLASSES = {
			"sun/security/ssl/RSAClientKeyExchange$RSAClientKeyExchangeMessage",
	};

	/**
	 * Class to transform that contains RSA secrets in server case.
	 */
	private static String RSA_PREMASTER_SECRET_CLASS= "sun/security/ssl/RSAKeyExchange$RSAPremasterSecret";


	/**
	 * Classes to transform to obtain CLIENT_RANDOM secrets.
	 */
	private static String[] CLIENT_KEY_EXCHANGE_CLASSES = {
			  "sun/security/ssl/RSAClientKeyExchange$RSAClientKeyExchangeProducer",
			  "sun/security/ssl/RSAClientKeyExchange$RSAClientKeyExchangeConsumer",
			  "sun/security/ssl/ECDHClientKeyExchange$ECDHEClientKeyExchangeProducer",
			  "sun/security/ssl/ECDHClientKeyExchange$ECDHEClientKeyExchangeConsumer",
			  "sun/security/ssl/ECDHClientKeyExchange$ECDHClientKeyExchangeProducer",
			  "sun/security/ssl/ECDHClientKeyExchange$ECDHClientKeyExchangeConsumer",
			  "sun/security/ssl/DHClientKeyExchange$DHClientKeyExchangeProducer",
			  "sun/security/ssl/DHClientKeyExchange$DHClientKeyExchangeConsumer"
	};

	/**
	 *  Classes to transform to obtain TLS1.3 secrets.
	 */
	private static String[] KEY_AGREEMENT_KEY_DERIVATION_CLASSES = {
			"sun/security/ssl/DHKeyExchange$DHEKAGenerator$DHEKAKeyDerivation",
			"sun/security/ssl/ECDHKeyExchange$ECDHEKAKeyDerivation"
	};

	private static String SECRET_DERIVATION_CLASS = "sun/security/ssl/SSLSecretDerivation";

	private static Map<String,Function<String,ClassTransform>> classesToTransform = new ConcurrentHashMap<>();

	/**
	 * Agent entry point.
	 */
	public static void premain(String agentArgs, Instrumentation inst) throws IOException {
		putClassesToTransform(RSA_CLASSES, RSAClientKeyExchangeTransformer::new);
		classesToTransform.put(RSA_PREMASTER_SECRET_CLASS, RSAPremasterSecretTransformer::new);
		putClassesToTransform(CLIENT_KEY_EXCHANGE_CLASSES, ClientKeyExchangeTransformer::new);
		putClassesToTransform(KEY_AGREEMENT_KEY_DERIVATION_CLASSES, KeyAgreementKeyDerivationTransformer::new);
		classesToTransform.put(SECRET_DERIVATION_CLASS, SecretDerivationTransformer::new);

		Set<String> classNamesToInstrument = new HashSet<String>();
		for (String rawClassName : classesToTransform.keySet()) {
			classNamesToInstrument.add(rawClassName.replace('/', '.'));
		}
		for (Class<?> c : inst.getAllLoadedClasses()) {
			if (classNamesToInstrument.contains(c.getName()))
				throw new IllegalStateException(c.getName() + " class already loaded");
		}
		inst.addTransformer(new TransformerMain());
		// parse agent arguments; first argument is always file name
		final String[] args = agentArgs.split(Pattern.quote(Character.toString(File.pathSeparatorChar)));
		boolean quiet = false, detailed = false, stdout = false;
		for (int i = 1; i < args.length; i++) {
			if (args[i].equals("quiet")) {
				quiet = true;
			}
			if (args[i].equals("stdout")) {
				stdout = true;
			}
			if (args[i].equals("detailed")) {
				detailed = true;
			}
		}
		String fileNameArg = args[0];

		// compatibility: if the log file's name starts with =,
		// then activate detailed logging
		if (fileNameArg.startsWith("=")) {
			fileNameArg = fileNameArg.substring(1);
			detailed = true;
		}
		PrintStream console = System.err;
		if (quiet) {
			console = new PrintStream(new ByteArrayOutputStream());
		} else if (stdout) {
			console = System.out;
		}
		if (detailed) {
			System.setProperty(LogWriter.VERBOSE_PROPERTY_NAME, "true");
			console.println("Verbose SSL logging activated");
		}
		final String sslLogPath = new File(fileNameArg).getCanonicalPath();
		System.setProperty(LogWriter.LOGFILE_PROPERTY_NAME, sslLogPath);
		LogWriter.logLine("# SSL/TLS secrets log file, generated by jSSLKeyLog", null);

		// if we are allowed to, write the name of the log file to console
		console.println("Logging all SSL session keys to: " + sslLogPath);
	}

	private static void putClassesToTransform(String[] classNames, Function<String,ClassTransform> constructor) {
		for(String className: classNames) {
			classesToTransform.put(className, constructor);
		}
	}

	@Override
	public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
		Function<String, ClassTransform> transformConstructor = classesToTransform.get(className);
		if (transformConstructor != null) {
			ClassFile cf = ClassFile.of();
			return cf.transformClass(cf.parse(classfileBuffer), transformConstructor.apply(className));
		}
		return null;
	}
}
