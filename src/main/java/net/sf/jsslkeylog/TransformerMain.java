package net.sf.jsslkeylog;

import java.io.File;
import java.io.IOException;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Pattern;
import java.util.Set;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

/**
 * Main transformer class that implements the required transformations to get
 * the SSL secrets.
 */
public class TransformerMain implements ClassFileTransformer {

	/**
	 * Classes to transform that contain RSA secrets (by Java version).
	 */
	private static String[] RSA_CLASSES = {
			"sun/security/ssl/RSAClientKeyExchange", // Java 7
			"sun/security/ssl/RSAClientKeyExchange$RSAClientKeyExchangeMessage", // Java 11
	};
	
	/**
	 * Class to transform that contains RSA secrets in server case.
	 */
	private static String RSA_PREMASTER_SECRET_CLASS= "sun/security/ssl/RSAKeyExchange$RSAPremasterSecret"; // Java 11

	
	/**
	 * Class to transform that contains CLIENT_RANDOM secrets.
	 */
	private static String HANDSHAKER_CLASS = "sun/security/ssl/Handshaker"; // Java 7
	
	/**
	 * Classes to transform to obtain CLIENT_RANDOM secrets.
	 */
	private static String[] CLIENT_KEY_EXCHANGE_CLASSES = { // Java 11
			  "sun/security/ssl/RSAClientKeyExchange$RSAClientKeyExchangeProducer",
			  "sun/security/ssl/RSAClientKeyExchange$RSAClientKeyExchangeConsumer",
			  "sun/security/ssl/ECDHClientKeyExchange$ECDHEClientKeyExchangeProducer",
			  "sun/security/ssl/ECDHClientKeyExchange$ECDHEClientKeyExchangeConsumer",
			  "sun/security/ssl/ECDHClientKeyExchange$ECDHClientKeyExchangeProducer",
			  "sun/security/ssl/ECDHClientKeyExchange$ECDHClientKeyExchangeConsumer",
			  "sun/security/ssl/DHClientKeyExchange$DHClientKeyExchangeProducer",
			  "sun/security/ssl/DHClientKeyExchange$DHClientKeyExchangeConsumer"
	};

	/**
	 *  Classes to transform to obtain TLS1.3 secrets.
	 */
	private static String[] KEY_AGREEMENT_KEY_DERIVATION_CLASSES = { // Java 11
			"sun/security/ssl/DHKeyExchange$DHEKAGenerator$DHEKAKeyDerivation",
			"sun/security/ssl/ECDHKeyExchange$ECDHEKAKeyDerivation"
	};
	
	private static String SECRET_DERIVATION_CLASS = "sun/security/ssl/SSLSecretDerivation"; // Java 11
	
	/**
	 * Agent entry point.
	 */
	public static void premain(String agentArgs, Instrumentation inst) throws IOException {
		List<String> rawClassNamesToInstrument = new ArrayList<String>();
		rawClassNamesToInstrument.addAll(Arrays.asList(RSA_CLASSES));
		rawClassNamesToInstrument.add(HANDSHAKER_CLASS);
		rawClassNamesToInstrument.add(RSA_PREMASTER_SECRET_CLASS);
		rawClassNamesToInstrument.addAll(Arrays.asList(CLIENT_KEY_EXCHANGE_CLASSES));
		rawClassNamesToInstrument.addAll(Arrays.asList(KEY_AGREEMENT_KEY_DERIVATION_CLASSES));
		rawClassNamesToInstrument.add(SECRET_DERIVATION_CLASS);
		Set<String> classNamesToInstrument = new HashSet<String>();
		for (String rawClassName : rawClassNamesToInstrument) {
			classNamesToInstrument.add(rawClassName.replace('/', '.'));
		}
		for (Class<?> c : inst.getAllLoadedClasses()) {
			if (classNamesToInstrument.contains(c.getName()))
				throw new IllegalStateException(c.getName() + " class already loaded");
		}
		inst.addTransformer(new TransformerMain());
		// parse agent arguments; first argument is always file name
		final String[] args = agentArgs.split(Pattern.quote(Character.toString(File.pathSeparatorChar)));
		boolean detailed = false;
		for (int i = 1; i < args.length; i++) {
			if (args[i].equals("detailed")) {
				detailed = true;
			}
		}
		String fileNameArg = args[0];

		// compatibility: if the log file's name starts with =,
		// then activate detailed logging
		if (fileNameArg.startsWith("=")) {
			fileNameArg = fileNameArg.substring(1);
			detailed = true;
		}
		if (detailed) {
			System.setProperty(LogWriter.VERBOSE_PROPERTY_NAME, "true");
		}
		final String sslLogPath = new File(fileNameArg).getCanonicalPath();
		System.setProperty(LogWriter.LOGFILE_PROPERTY_NAME, sslLogPath);
		LogWriter.logLine("# SSL/TLS secrets log file, generated by jSSLKeyLog", null);

		System.err.println("Logging all SSL session keys to: " + sslLogPath);
	}

	public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
		for (String rsaClass : RSA_CLASSES) {
			if (className.equals(rsaClass)) {
				return transform(classfileBuffer, new RSAClientKeyExchangeTransformer(rsaClass));
			}
		}
		if (className.equals(HANDSHAKER_CLASS)) {
			return transform(classfileBuffer, new HandshakerTransformer(HANDSHAKER_CLASS));
		}
		if (className.equals(RSA_PREMASTER_SECRET_CLASS)) {
			return transform(classfileBuffer, new RSAPremasterSecretTransformer(RSA_PREMASTER_SECRET_CLASS));
		}
		for (String clientKeyExchangeClass : CLIENT_KEY_EXCHANGE_CLASSES) {
			if (className.equals(clientKeyExchangeClass)) {
				return transform(classfileBuffer, new ClientKeyExchangeTransformer(clientKeyExchangeClass));
			}
		}
		for (String keyAgreementClass : KEY_AGREEMENT_KEY_DERIVATION_CLASSES) {
			if (className.equals(keyAgreementClass)) {
				return transform(classfileBuffer, new KeyAgreementKeyDerivationTransformer(keyAgreementClass));
			}
		}		
		if (className.equals(SECRET_DERIVATION_CLASS)) {
			return transform(classfileBuffer, new SecretDerivationTransformer(SECRET_DERIVATION_CLASS));
		}
		return null;
	}

	private byte[] transform(byte[] classfileBuffer, AbstractTransformer transformer) {
		ClassReader cr = new ClassReader(classfileBuffer);
		ClassWriter cw = new ClassWriter(0);
		transformer.setNextVisitor(cw);
		cr.accept(transformer, 0);
		return cw.toByteArray();
	}
}
